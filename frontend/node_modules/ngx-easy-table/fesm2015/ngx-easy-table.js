import { from } from 'rxjs';
import { flatMap, groupBy, reduce } from 'rxjs/operators';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import { CommonModule } from '@angular/common';
import { Injectable, ChangeDetectionStrategy, Component, EventEmitter, Input, Output, ViewChild, ChangeDetectorRef, ContentChild, TemplateRef, Pipe, NgModule } from '@angular/core';
import { NgxPaginationModule } from 'ngx-pagination';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const STYLE = {
    TINY: 'tiny',
    BIG: 'big',
    NORMAL: 'normal',
};
/** @enum {string} */
const THEME = {
    LIGHT: 'light',
    DARK: 'dark',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const Event = {
    onPagination: 'onPagination',
    onOrder: 'onOrder',
    onGlobalSearch: 'onGlobalSearch',
    onSearch: 'onSearch',
    onClick: 'onClick',
    onDoubleClick: 'onDoubleClick',
    onCheckboxSelect: 'onCheckboxSelect',
    onSelectAll: 'onSelectAll',
    onColumnResizeMouseDown: 'onColumnResizeMouseDown',
    onColumnResizeMouseUp: 'onColumnResizeMouseUp',
    onRowDrop: 'onRowDrop',
    onRowCollapsedShow: 'onRowCollapsedShow',
    onRowCollapsedHide: 'onRowCollapsedHide',
    onRowContextMenu: 'onRowContextMenu',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const API = {
    rowContextMenuClicked: 'rowContextMenuClicked',
    setInputValue: 'setInputValue',
    toolPanelClicked: 'toolPanelClicked',
    onGlobalSearch: 'onGlobalSearch',
    setPaginationCurrentPage: 'setPaginationCurrentPage',
    getPaginationCurrentPage: 'getPaginationCurrentPage',
    getPaginationTotalItems: 'getPaginationTotalItems',
    getPaginationLastPage: 'getPaginationLastPage',
    setPaginationRange: 'setPaginationRange',
    setPaginationPreviousLabel: 'setPaginationPreviousLabel',
    setPaginationNextLabel: 'setPaginationNextLabel',
    setPaginationDisplayLimit: 'setPaginationDisplayLimit',
    setTableClass: 'setTableClass',
    setRowClass: 'setRowClass',
    setCellClass: 'setCellClass',
    setRowStyle: 'setRowStyle',
    setCellStyle: 'setCellStyle',
    sortBy: 'sortBy',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DefaultConfig = {
    searchEnabled: false,
    headerEnabled: true,
    orderEnabled: true,
    orderEventOnly: false,
    paginationEnabled: true,
    exportEnabled: false,
    clickEvent: true,
    selectRow: false,
    selectCol: false,
    selectCell: false,
    rows: 10,
    additionalActions: false,
    serverPagination: false,
    isLoading: false,
    detailsTemplate: false,
    groupRows: false,
    paginationRangeEnabled: true,
    collapseAllRows: false,
    checkboxes: false,
    resizeColumn: false,
    fixedColumnWidth: true,
    horizontalScroll: false,
    draggable: false,
    logger: false,
    showDetailsArrow: false,
    showContextMenu: false,
    persistState: false,
    paginationMaxSize: 5,
    threeWaySort: false,
    tableLayout: {
        style: STYLE.NORMAL,
        theme: THEME.LIGHT,
        borderless: false,
        hover: true,
        striped: false,
    },
};
class DefaultConfigService {
}
DefaultConfigService.config = DefaultConfig;
DefaultConfigService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationComponent {
    constructor() {
        this.updateRange = new EventEmitter();
        this.ranges = [5, 10, 25, 50, 100];
        this.limit = DefaultConfigService.config.rows;
        this.showRange = false;
        this.screenReaderPaginationLabel = 'Pagination';
        this.screenReaderPageLabel = 'page';
        this.screenReaderCurrentLabel = 'You are on page';
        this.previousLabel = '';
        this.nextLabel = '';
        this.directionLinks = true;
    }
    /**
     * @param {?} page
     * @return {?}
     */
    onPageChange(page) {
        this.updateRange.emit({
            page,
            limit: this.limit,
        });
    }
    /**
     * @param {?} limit
     * @param {?} callFromAPI
     * @return {?}
     */
    changeLimit(limit, callFromAPI) {
        if (!callFromAPI) {
            this.showRange = !this.showRange;
        }
        this.limit = limit;
        this.updateRange.emit({
            page: 1,
            limit,
        });
    }
}
PaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'pagination',
                template: "<div class=\"ngx-pagination-wrapper\"\n     [class.ngx-table__table--dark-pagination-wrapper]=\"config.tableLayout.theme === 'dark'\">\n  <div class=\"ngx-pagination-steps\">\n    <pagination-template\n      #paginationDirective=\"paginationApi\"\n      id=\"pagination-controls\"\n      [id]=\"id\"\n      [class.ngx-table__table--dark-pagination]=\"config.tableLayout.theme === 'dark'\"\n      [maxSize]=\"config.paginationMaxSize || 5\"\n      (pageChange)=\"onPageChange($event)\">\n      <ul class=\"ngx-pagination\"\n          role=\"navigation\"\n          [attr.aria-label]=\"screenReaderPaginationLabel\"\n          [class.responsive]=\"true\">\n        <li class=\"pagination-previous\" [class.disabled]=\"paginationDirective.isFirstPage()\" *ngIf=\"directionLinks\">\n          <a tabindex=\"0\" *ngIf=\"1 < paginationDirective.getCurrent()\" (keyup.enter)=\"paginationDirective.previous()\"\n             (click)=\"paginationDirective.previous()\"\n             [attr.aria-label]=\"previousLabel + ' ' + screenReaderPageLabel\">\n            {{ previousLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n          </a>\n          <span *ngIf=\"paginationDirective.isFirstPage()\">\n                {{ previousLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n            </span>\n        </li>\n        <li class=\"small-screen\">\n          {{ paginationDirective.getCurrent() }} / {{ paginationDirective.getLastPage() }}\n        </li>\n        <li [class.current]=\"paginationDirective.getCurrent() === page.value\"\n            [class.ellipsis]=\"page.label === '...'\"\n            *ngFor=\"let page of paginationDirective.pages\">\n          <a tabindex=\"0\" (keyup.enter)=\"paginationDirective.setCurrent(page.value)\"\n             (click)=\"paginationDirective.setCurrent(page.value)\"\n             *ngIf=\"paginationDirective.getCurrent() !== page.value\">\n            <span class=\"show-for-sr\">{{ screenReaderPageLabel }} </span>\n            <span>{{ page.label }}</span>\n          </a>\n          <ng-container *ngIf=\"paginationDirective.getCurrent() === page.value\">\n            <span class=\"show-for-sr\">{{ screenReaderCurrentLabel }} </span>\n            <span>{{ page.label }}</span>\n          </ng-container>\n        </li>\n        <li class=\"pagination-next\" [class.disabled]=\"paginationDirective.isLastPage()\" *ngIf=\"directionLinks\">\n          <a tabindex=\"0\" *ngIf=\"!paginationDirective.isLastPage()\" (keyup.enter)=\"paginationDirective.next()\"\n             (click)=\"paginationDirective.next()\"\n             [attr.aria-label]=\"nextLabel + ' ' + screenReaderPageLabel\">\n            {{ nextLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n          </a>\n          <span *ngIf=\"paginationDirective.isLastPage()\">\n                 {{ nextLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n            </span>\n        </li>\n      </ul>\n    </pagination-template>\n  </div>\n  <div class=\"ngx-pagination-range\"\n       [class.ngx-table__table--dark-pagination-range]=\"config.tableLayout.theme === 'dark'\"\n       *ngIf=\"config.paginationRangeEnabled\">\n    <div class=\"ngx-dropdown ngx-pagination-range-dropdown\"\n         [class.ngx-active]=\"showRange\"\n         id=\"rowAmount\">\n      <div class=\"ngx-btn-group\">\n        <div class=\"ngx-pagination-range-dropdown-button\"\n             (click)=\"showRange = !showRange\">\n          {{limit}} <i class=\"ngx-icon ngx-icon-arrow-down\"></i>\n        </div>\n        <ul class=\"ngx-menu\" *ngIf=\"showRange\">\n          <li class=\"ngx-pagination-range-dropdown-button-item\"\n              (click)=\"changeLimit(limit, false)\"\n              *ngFor=\"let limit of ranges\">\n            <span>{{limit}}</span>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
PaginationComponent.propDecorators = {
    paginationDirective: [{ type: ViewChild, args: ['paginationDirective',] }],
    pagination: [{ type: Input }],
    config: [{ type: Input }],
    id: [{ type: Input }],
    updateRange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GroupRowsService {
    /**
     * @template T
     * @param {?} data
     * @param {?} groupRowsBy
     * @return {?}
     */
    static doGroupRows(data, groupRowsBy) {
        /** @type {?} */
        const grouped = [];
        from(data).pipe(groupBy((/**
         * @param {?} row
         * @return {?}
         */
        (row) => row[groupRowsBy])), flatMap((/**
         * @param {?} group
         * @return {?}
         */
        (group) => group.pipe(reduce((/**
         * @param {?} acc
         * @param {?} curr
         * @return {?}
         */
        (acc, curr) => [...acc, curr]), []))))).subscribe((/**
         * @param {?} row
         * @return {?}
         */
        (row) => grouped.push(row)));
        return grouped;
    }
}
GroupRowsService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StyleService {
    /**
     * @param {?} val
     * @return {?}
     */
    static setRowClass(val) {
        /** @type {?} */
        const selector = `#table > tbody > tr:nth-child(${val.row})`;
        /** @type {?} */
        const row = document.querySelector(selector);
        if (row) {
            row.className = val.className;
        }
    }
    /**
     * @param {?} val
     * @return {?}
     */
    static setCellClass(val) {
        /** @type {?} */
        const selector = `#table > tbody > tr:nth-child(${val.row}) > td:nth-child(${val.cell})`;
        /** @type {?} */
        const cell = document.querySelector(selector);
        if (cell) {
            cell.className = val.className;
        }
    }
    /**
     * @param {?} val
     * @return {?}
     */
    static setRowStyle(val) {
        /** @type {?} */
        const selector = `#table > tbody > tr:nth-child(${val.row})`;
        /** @type {?} */
        const row = document.querySelector(selector);
        if (row) {
            // tslint:disable-next-line:no-string-literal
            row.style[val.attr] = val.value;
        }
    }
    /**
     * @param {?} val
     * @return {?}
     */
    static setCellStyle(val) {
        /** @type {?} */
        const selector = `#table > tbody > tr:nth-child(${val.row}) > td:nth-child(${val.cell})`;
        /** @type {?} */
        const cell = document.querySelector(selector);
        if (cell) {
            // tslint:disable-next-line:no-string-literal
            cell.style[val.attr] = val.value;
        }
    }
}
StyleService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BaseComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this.tableClass = null;
        this.grouped = [];
        this.menuActive = false;
        this.isSelected = false;
        this.page = 1;
        this.count = null;
        this.sortState = new Map();
        this.sortKey = null;
        this.rowContextMenuPosition = {
            top: null,
            left: null,
            value: null,
        };
        this.sortBy = {
            key: '',
            order: 'asc',
        };
        this.selectedDetailsTemplateRowId = new Set();
        this.loadingHeight = '30px';
        this.onSelectAllBinded = this.onSelectAll.bind(this);
        this.id = 'table';
        this.event = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set configuration(value) {
        this.config = value;
    }
    /**
     * @return {?}
     */
    get configuration() {
        return this.config;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.columns) {
            console.error('[columns] property required!');
        }
        if (this.configuration) {
            DefaultConfigService.config = this.configuration;
        }
        this.config = DefaultConfigService.config;
        this.limit = this.config.rows;
        if (this.groupRowsBy) {
            this.grouped = GroupRowsService.doGroupRows(this.data, this.groupRowsBy);
        }
        this.doDecodePersistedState();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const data = changes.data;
        /** @type {?} */
        const pagination = changes.pagination;
        /** @type {?} */
        const groupRowsBy = changes.groupRowsBy;
        this.toggleRowIndex = changes.toggleRowIndex;
        if (data && data.currentValue) {
            this.doApplyData(data);
        }
        if (pagination && pagination.currentValue) {
            this.count = pagination.currentValue.count;
        }
        if (groupRowsBy && groupRowsBy.currentValue) {
            this.grouped = GroupRowsService.doGroupRows(this.data, this.groupRowsBy);
        }
        if (this.toggleRowIndex && this.toggleRowIndex.currentValue) {
            /** @type {?} */
            const row = this.toggleRowIndex.currentValue;
            this.collapseRow(row.index);
        }
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isOrderEnabled(column) {
        /** @type {?} */
        const columnOrderEnabled = column.orderEnabled === undefined ? true : !!column.orderEnabled;
        return DefaultConfigService.config.orderEnabled && columnOrderEnabled;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    orderBy(column) {
        if (typeof column.orderEnabled !== 'undefined' && !column.orderEnabled) {
            return;
        }
        this.sortKey = column.key;
        if (!DefaultConfigService.config.orderEnabled || this.sortKey === '') {
            return;
        }
        this.setColumnOrder(this.sortKey);
        if (!DefaultConfigService.config.orderEventOnly && !column.orderEventOnly) {
            this.sortBy.key = this.sortKey;
            this.sortBy.order = this.sortState.get(this.sortKey);
        }
        else {
            this.sortBy.key = '';
            this.sortBy.order = '';
        }
        if (!DefaultConfigService.config.serverPagination) {
            this.data = [...this.data];
        }
        this.sortBy = Object.assign({}, this.sortBy);
        /** @type {?} */
        const value = {
            key: this.sortKey,
            order: this.sortState.get(this.sortKey),
        };
        this.emitEvent(Event.onOrder, value);
    }
    /**
     * @param {?} $event
     * @param {?} row
     * @param {?} key
     * @param {?} colIndex
     * @param {?} rowIndex
     * @return {?}
     */
    onClick($event, row, key, colIndex, rowIndex) {
        if (DefaultConfigService.config.selectRow) {
            this.selectedRow = rowIndex;
        }
        if (DefaultConfigService.config.selectCol && colIndex) {
            this.selectedCol = colIndex;
        }
        if (DefaultConfigService.config.selectCell && colIndex) {
            this.selectedRow = rowIndex;
            this.selectedCol = colIndex;
        }
        if (DefaultConfigService.config.clickEvent) {
            /** @type {?} */
            const value = {
                event: $event,
                row,
                key,
                rowId: rowIndex,
                colId: colIndex,
            };
            this.emitEvent(Event.onClick, value);
        }
    }
    /**
     * @param {?} $event
     * @param {?} row
     * @param {?} key
     * @param {?} colIndex
     * @param {?} rowIndex
     * @return {?}
     */
    onDoubleClick($event, row, key, colIndex, rowIndex) {
        /** @type {?} */
        const value = {
            event: $event,
            row,
            key,
            rowId: rowIndex,
            colId: colIndex,
        };
        this.emitEvent(Event.onDoubleClick, value);
    }
    /**
     * @param {?} $event
     * @param {?} row
     * @param {?} rowIndex
     * @return {?}
     */
    onCheckboxSelect($event, row, rowIndex) {
        /** @type {?} */
        const value = {
            event: $event,
            row,
            rowId: rowIndex,
        };
        this.emitEvent(Event.onCheckboxSelect, value);
    }
    /**
     * @return {?}
     */
    onSelectAll() {
        this.isSelected = !this.isSelected;
        this.emitEvent(Event.onSelectAll, this.isSelected);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onSearch($event) {
        if (!DefaultConfigService.config.serverPagination) {
            this.term = $event;
        }
        this.emitEvent(Event.onSearch, $event);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onGlobalSearch(value) {
        if (!DefaultConfigService.config.serverPagination) {
            this.globalSearchTerm = value;
        }
        this.emitEvent(Event.onGlobalSearch, value);
    }
    /**
     * @param {?} pagination
     * @return {?}
     */
    onPagination(pagination) {
        this.page = pagination.page;
        this.limit = pagination.limit;
        this.emitEvent(Event.onPagination, pagination);
    }
    /**
     * @private
     * @param {?} event
     * @param {?} value
     * @return {?}
     */
    emitEvent(event, value) {
        this.event.emit({ event, value });
        if (this.config.persistState) {
            localStorage.setItem(event, JSON.stringify(value));
        }
        if (this.config.logger) {
            // tslint:disable-next-line:no-console
            console.log({ event, value });
        }
    }
    /**
     * @param {?} rowIndex
     * @return {?}
     */
    collapseRow(rowIndex) {
        if (this.selectedDetailsTemplateRowId.has(rowIndex)) {
            this.selectedDetailsTemplateRowId.delete(rowIndex);
            this.emitEvent(Event.onRowCollapsedHide, rowIndex);
        }
        else {
            this.selectedDetailsTemplateRowId.add(rowIndex);
            this.emitEvent(Event.onRowCollapsedShow, rowIndex);
        }
    }
    /**
     * @private
     * @return {?}
     */
    doDecodePersistedState() {
        if (!this.config.persistState) {
            return;
        }
        /** @type {?} */
        const pagination = localStorage.getItem(Event.onPagination);
        /** @type {?} */
        const sort = localStorage.getItem(Event.onOrder);
        /** @type {?} */
        const search = localStorage.getItem(Event.onSearch);
        if (pagination) {
            this.onPagination(JSON.parse(pagination));
        }
        if (sort) {
            const { key, order } = JSON.parse(sort);
            this.sortBy.key = key;
            this.sortBy.order = order;
            this.data = [...this.data];
        }
        if (search) {
            this.term = JSON.parse(search);
        }
    }
    /**
     * @param {?} rowIndex
     * @return {?}
     */
    isRowCollapsed(rowIndex) {
        if (this.config.collapseAllRows) {
            return true;
        }
        return this.selectedDetailsTemplateRowId.has(rowIndex);
    }
    /**
     * @param {?} event
     * @param {?} th
     * @return {?}
     */
    onMouseDown(event, th) {
        if (!this.config.resizeColumn) {
            return;
        }
        this.th = th;
        this.startOffset = th.offsetWidth - event.pageX;
        this.emitEvent(Event.onColumnResizeMouseDown, event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        if (!this.config.resizeColumn) {
            return;
        }
        if (this.th && this.th.style) {
            this.th.style.width = this.startOffset + event.pageX + 'px';
            this.th.style.cursor = 'col-resize';
            this.th.style['user-select'] = 'none';
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        if (!this.config.resizeColumn) {
            return;
        }
        this.emitEvent(Event.onColumnResizeMouseUp, event);
        this.th.style.cursor = 'default';
        this.th = undefined;
    }
    /**
     * @return {?}
     */
    get isLoading() {
        /** @type {?} */
        const table = (/** @type {?} */ (document.getElementById('table')));
        if (table && table.rows && table.rows.length > 3) {
            this.getLoadingHeight(table.rows);
        }
        return this.config.isLoading;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    getLoadingHeight(rows) {
        /** @type {?} */
        const searchEnabled = this.config.searchEnabled ? 1 : 0;
        /** @type {?} */
        const headerEnabled = this.config.headerEnabled ? 1 : 0;
        /** @type {?} */
        const borderTrHeight = 1;
        /** @type {?} */
        const borderDivHeight = 2;
        this.loadingHeight = (rows.length - searchEnabled - headerEnabled) * (rows[3].offsetHeight - borderTrHeight) - borderDivHeight + 'px';
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getColumnWidth(column) {
        if (column.width) {
            return column.width;
        }
        return this.config.fixedColumnWidth ? 100 / this.columns.length + '%' : null;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getColumnDefinition(column) {
        return column.searchEnabled || typeof column.searchEnabled === 'undefined';
    }
    /**
     * @return {?}
     */
    get arrowDefinition() {
        return this.config.showDetailsArrow || typeof this.config.showDetailsArrow === 'undefined';
    }
    /**
     * @param {?} $event
     * @param {?} row
     * @param {?} key
     * @param {?} colIndex
     * @param {?} rowIndex
     * @return {?}
     */
    onRowContextMenu($event, row, key, colIndex, rowIndex) {
        if (!this.config.showContextMenu) {
            return;
        }
        $event.preventDefault();
        /** @type {?} */
        const value = {
            event: $event,
            row,
            key,
            rowId: rowIndex,
            colId: colIndex,
        };
        this.rowContextMenuPosition = {
            top: `${$event.y - 10}px`,
            left: `${$event.x - 10}px`,
            value,
        };
        this.emitEvent(Event.onRowContextMenu, value);
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    doApplyData(data) {
        /** @type {?} */
        const column = this.columns.find((/**
         * @param {?} c
         * @return {?}
         */
        (c) => !!c.orderBy));
        if (column) {
            this.sortState.set(this.sortKey, (column.orderBy === 'asc') ? 'desc' : 'asc');
            this.orderBy(column);
        }
        else {
            this.data = [...data.currentValue];
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDrop(event) {
        this.emitEvent(Event.onRowDrop, event);
        moveItemInArray(this.data, event.previousIndex, event.currentIndex);
    }
    // DO NOT REMOVE. It is called from parent component. See src/app/demo/api-doc/api-doc.component.ts
    /**
     * @param {?} event
     * @return {?}
     */
    apiEvent(event) {
        return this.bindApi(event);
    }
    // tslint:disable:no-big-function cognitive-complexity
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    bindApi(event) {
        switch (event.type) {
            case API.rowContextMenuClicked:
                this.rowContextMenuPosition = {
                    top: null,
                    left: null,
                    value: null,
                };
                break;
            case API.toolPanelClicked:
                // TODO
                break;
            case API.setInputValue:
                if (this.config.searchEnabled) {
                    event.value.forEach((/**
                     * @param {?} input
                     * @return {?}
                     */
                    (input) => {
                        /** @type {?} */
                        const element = ((/** @type {?} */ (document.getElementById(`search_${input.key}`))));
                        if (!element) {
                            console.error(`Column '${input.key}' not available in the DOM. Have you misspelled a name?`);
                        }
                        else {
                            element.value = input.value;
                        }
                    }));
                }
                this.onSearch(event.value);
                this.cdr.detectChanges();
                break;
            case API.onGlobalSearch:
                this.onGlobalSearch(event.value);
                this.cdr.detectChanges();
                break;
            case API.setRowClass:
                if (Array.isArray(event.value)) {
                    event.value.forEach((/**
                     * @param {?} val
                     * @return {?}
                     */
                    (val) => StyleService.setRowClass(val)));
                    break;
                }
                StyleService.setRowClass(event.value);
                this.cdr.detectChanges();
                break;
            case API.setCellClass:
                if (Array.isArray(event.value)) {
                    event.value.forEach((/**
                     * @param {?} val
                     * @return {?}
                     */
                    (val) => StyleService.setCellClass(val)));
                    break;
                }
                StyleService.setCellClass(event.value);
                break;
            case API.setRowStyle:
                if (Array.isArray(event.value)) {
                    event.value.forEach((/**
                     * @param {?} val
                     * @return {?}
                     */
                    (val) => StyleService.setRowStyle(val)));
                    break;
                }
                StyleService.setRowStyle(event.value);
                break;
            case API.setCellStyle:
                if (Array.isArray(event.value)) {
                    event.value.forEach((/**
                     * @param {?} val
                     * @return {?}
                     */
                    (val) => StyleService.setCellStyle(val)));
                    break;
                }
                StyleService.setCellStyle(event.value);
                break;
            case API.setTableClass:
                this.tableClass = event.value;
                this.cdr.detectChanges();
                break;
            case API.getPaginationTotalItems:
                return this.paginationComponent.paginationDirective.getTotalItems();
            case API.setPaginationCurrentPage:
                this.paginationComponent.paginationDirective.setCurrent(event.value);
                break;
            case API.setPaginationRange:
                this.paginationComponent.ranges = event.value;
                break;
            case API.setPaginationPreviousLabel:
                this.paginationComponent.previousLabel = event.value;
                break;
            case API.setPaginationNextLabel:
                this.paginationComponent.nextLabel = event.value;
                break;
            case API.setPaginationDisplayLimit:
                this.paginationComponent.changeLimit(event.value, true);
                break;
            case API.sortBy:
                /** @type {?} */
                const column = { title: '', key: event.value.column, orderBy: event.value.order };
                this.orderBy(column);
                this.cdr.detectChanges();
                break;
            default:
                break;
        }
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    setColumnOrder(key) {
        switch (this.sortState.get(key)) {
            case '':
            case undefined:
                this.sortState.set(key, 'desc');
                break;
            case 'asc':
                this.config.threeWaySort ?
                    this.sortState.set(key, '') :
                    this.sortState.set(key, 'desc');
                break;
            case 'desc':
                this.sortState.set(key, 'asc');
                break;
        }
        if (this.sortState.size > 1) {
            /** @type {?} */
            const temp = this.sortState.get(key);
            this.sortState.clear();
            this.sortState.set(key, temp);
        }
    }
}
BaseComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-table',
                providers: [DefaultConfigService, GroupRowsService, StyleService],
                template: "<div class=\"ngx-container\">\n  <table [id]=\"id\"\n         [ngClass]=\"(tableClass === null || tableClass === '') ? 'ngx-table' : tableClass\"\n         [class.ngx-table__table--tiny]=\"config.tableLayout.style === 'tiny'\"\n         [class.ngx-table__table--normal]=\"config.tableLayout.style === 'normal'\"\n         [class.ngx-table__table--big]=\"config.tableLayout.style === 'big'\"\n         [class.ngx-table__table--borderless]=\"config.tableLayout.borderless\"\n         [class.ngx-table__table--dark]=\"config.tableLayout.theme === 'dark'\"\n         [class.ngx-table__table--hoverable]=\"config.tableLayout.hover\"\n         [class.ngx-table__table--striped]=\"config.tableLayout.striped\"\n         [class.ngx-table__horizontal-scroll]=\"config.horizontalScroll && !isLoading\">\n    <thead>\n    <tr class=\"ngx-table__header\" *ngIf=\"config.headerEnabled\">\n      <th *ngIf=\"config.checkboxes\" width=\"3%\">\n        <ng-container\n          *ngIf=\"selectAllTemplate\"\n          [ngTemplateOutlet]=\"selectAllTemplate\"\n          [ngTemplateOutletContext]=\"{ $implicit: onSelectAllBinded }\">\n        </ng-container>\n        <label class=\"ngx-form-checkbox\" *ngIf=\"!selectAllTemplate\">\n          <input type=\"checkbox\" (change)=\"onSelectAll()\">\n          <i class=\"ngx-form-icon\" id=\"selectAllCheckbox\"></i>\n        </label>\n      </th>\n      <ng-container *ngFor=\"let column of columns;\">\n        <th class=\"ngx-table__header-cell\"\n            #th\n            [attr.width]=\"getColumnWidth(column)\"\n            (mousedown)=\"onMouseDown($event, th)\"\n            (mouseup)=\"onMouseUp($event)\"\n            (mousemove)=\"onMouseMove($event)\">\n          <div (click)=\"orderBy(column)\" [class.pointer]=\"isOrderEnabled(column)\">\n            <div class=\"ngx-table__header-title\">{{ column.title }}<span>&nbsp;</span>\n              <div [style.display]=\"config.orderEnabled ? 'inline' : 'none' \">\n                <span *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === ''\"> -</span>\n                <i *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'asc'\"\n                   class=\"ngx-icon ngx-icon-arrow-up\">\n                </i>\n                <i *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'desc'\"\n                   class=\"ngx-icon ngx-icon-arrow-down\">\n                </i>\n              </div>\n            </div>\n          </div>\n          <div class=\"ngx-table__column-resizer\" *ngIf=\"config.resizeColumn\"></div>\n        </th>\n      </ng-container>\n      <th *ngIf=\"config.additionalActions || config.detailsTemplate || config.collapseAllRows || config.groupRows\"\n          class=\"ngx-table__header-cell-additional-actions\">\n        <div class=\"ngx-dropdown ngx-active\"\n             *ngIf=\"config.additionalActions\"\n             [class.ngx-active]=\"menuActive\">\n          <a class=\"ngx-btn ngx-btn-link\" (click)=\"menuActive = !menuActive\">\n            <span class=\"ngx-icon ngx-icon-menu\"></span>\n          </a>\n          <ul class=\"ngx-menu ngx-table__table-menu\">\n            <li class=\"ngx-menu-item\">\n              <app-csv-export [data]=\"data\"\n                              *ngIf=\"config.exportEnabled\">\n              </app-csv-export>\n            </li>\n          </ul>\n        </div>\n      </th>\n    </tr>\n    <tr *ngIf=\"config.searchEnabled && !filtersTemplate\"\n        class=\"ngx-table__sort-header\">\n      <th *ngIf=\"config.checkboxes\"></th>\n      <ng-container *ngFor=\"let column of columns\">\n        <th>\n          <table-header\n            *ngIf=\"getColumnDefinition(column)\"\n            (update)=\"onSearch($event)\"\n            [column]=\"column\">\n          </table-header>\n        </th>\n      </ng-container>\n      <th *ngIf=\"config.additionalActions || config.detailsTemplate\"></th>\n    </tr>\n    <ng-container *ngIf=\"filtersTemplate\">\n      <tr>\n        <ng-container [ngTemplateOutlet]=\"filtersTemplate\">\n        </ng-container>\n      </tr>\n    </ng-container>\n    </thead>\n    <tbody *ngIf=\"data && !isLoading  && !config.draggable\">\n    <ng-container *ngIf=\"rowTemplate\">\n      <ul class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{'position': 'absolute', 'top': rowContextMenuPosition.top, 'left': rowContextMenuPosition.left }\"\n          *ngIf=\"rowContextMenuPosition.top\">\n        <ng-container\n          [ngTemplateOutlet]=\"rowContextMenu\"\n          [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value}\">\n        </ng-container>\n      </ul>\n      <ng-container *ngFor=\"let row of data | sort:sortBy | search:term | global:globalSearchTerm | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n              let rowIndex = index\">\n        <tr\n          (click)=\"onClick($event, row, '', null, rowIndex)\"\n          (contextmenu)=\"onRowContextMenu($event, row, '', null, rowIndex)\"\n          (dblclick)=\"onDoubleClick($event, row, '', null, rowIndex)\"\n          [class.ngx-table__table-row--selected]=\"rowIndex == selectedRow && !config.selectCell\">\n          <ng-container\n            [ngTemplateOutlet]=\"rowTemplate\"\n            [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\">\n          </ng-container>\n          <td *ngIf=\"config.detailsTemplate\">\n            <span class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\"\n                  (click)=\"collapseRow(rowIndex)\">\n            </span>\n          </td>\n        </tr>\n        <tr\n          *ngIf=\"(config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) || config.collapseAllRows\">\n          <td [attr.colspan]=\"columns.length + 1\">\n            <ng-container\n              [ngTemplateOutlet]=\"detailsTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex  }\">\n            </ng-container>\n          </td>\n        </tr>\n      </ng-container>\n    </ng-container>\n    <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n      <ul class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{'position': 'absolute', 'top': rowContextMenuPosition.top, 'left': rowContextMenuPosition.left }\"\n          *ngIf=\"rowContextMenuPosition.top\">\n        <ng-container\n          [ngTemplateOutlet]=\"rowContextMenu\"\n          [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value}\">\n        </ng-container>\n      </ul>\n      <ng-container\n        *ngFor=\"let row of data | sort:sortBy | search:term | global:globalSearchTerm | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n                  let rowIndex = index\">\n        <tr [class.ngx-table__table-row--selected]=\"rowIndex == selectedRow && !config.selectCell\">\n          <td *ngIf=\"config.checkboxes\">\n            <label class=\"ngx-form-checkbox\">\n              <input type=\"checkbox\"\n                     id=\"checkbox-{{rowIndex}}\"\n                     [checked]=\"isSelected\"\n                     (change)=\"onCheckboxSelect($event, row, rowIndex)\">\n              <i class=\"ngx-form-icon\"></i>\n            </label>\n          </td>\n          <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n            <td (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                (contextmenu)=\"onRowContextMenu($event, row, column.key, colIndex, rowIndex)\"\n                (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                [class.ngx-table__table-col--selected]=\"colIndex == selectedCol && !config.selectCell\"\n                [class.ngx-table__table-cell--selected]=\"colIndex == selectedCol && rowIndex == selectedRow && !config.selectCol && !config.selectRow\"\n            >\n              <div *ngIf=\"!column.cellTemplate\">{{ row | render:column.key }}</div>\n              <ng-container\n                *ngIf=\"column.cellTemplate\"\n                [ngTemplateOutlet]=\"column.cellTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: row, rowIndex: rowIndex }\">\n              </ng-container>\n            </td>\n          </ng-container>\n          <td *ngIf=\"config.additionalActions || config.detailsTemplate\">\n            <span class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\"\n                  (click)=\"collapseRow(rowIndex)\">\n            </span>\n          </td>\n        </tr>\n        <tr\n          *ngIf=\"(config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) || config.collapseAllRows\">\n          <td *ngIf=\"config.checkboxes\"></td>\n          <td [attr.colspan]=\"columns.length + 1\">\n            <ng-container\n              [ngTemplateOutlet]=\"detailsTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\">\n            </ng-container>\n          </td>\n        </tr>\n      </ng-container>\n    </ng-container>\n    <ng-container *ngIf=\"!rowTemplate && config.groupRows\">\n      <ng-container\n        *ngFor=\"let group of grouped | sort:sortBy:config | search:term:config | global:globalSearchTerm | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id }; let rowIndex = index\">\n        <tr>\n          <ng-container *ngIf=\"!groupRowsHeaderTemplate\">\n            <td [attr.colspan]=\"columns.length\">\n              <div>{{group[0][groupRowsBy]}} ({{group.length}})</div>\n            </td>\n          </ng-container>\n          <ng-container\n            *ngIf=\"groupRowsHeaderTemplate\"\n            [ngTemplateOutlet]=\"groupRowsHeaderTemplate\"\n            [ngTemplateOutletContext]=\"{\n              total: group.length,\n              key: groupRowsBy,\n              value: group[0] ? group[0][groupRowsBy] : '',\n              group: group,\n              index: rowIndex\n            }\">\n          </ng-container>\n          <td>\n            <span class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\"\n                  (click)=\"collapseRow(rowIndex)\">\n            </span>\n          </td>\n        </tr>\n        <ng-container *ngIf=\"selectedDetailsTemplateRowId.has(rowIndex)\">\n          <tr *ngFor=\"let row of group\">\n            <td *ngFor=\"let column of columns\">\n              {{ row | render:column.key }}\n              <!-- TODO allow users to add groupRowsTemplateRef -->\n            </td>\n            <td></td>\n          </tr>\n        </ng-container>\n      </ng-container>\n    </ng-container>\n    </tbody>\n    <tbody *ngIf=\"data && !config.isLoading && config.draggable\" cdkDropList (cdkDropListDropped)=\"onDrop($event)\">\n    <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n      <ng-container\n        *ngFor=\"let row of data | sort:sortBy | search:term | global:globalSearchTerm | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n                  let rowIndex = index\">\n        <tr class=\"ngx-draggable-row\" cdkDrag>\n          <td *ngIf=\"config.checkboxes\">\n            <label class=\"ngx-form-checkbox\">\n              <input type=\"checkbox\"\n                     id=\"checkbox-draggable-{{rowIndex}}\"\n                     [checked]=\"isSelected\"\n                     (change)=\"onCheckboxSelect($event, row, rowIndex)\">\n              <i class=\"ngx-form-icon\"></i>\n            </label>\n          </td>\n          <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n            <td (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                [class.ngx-table__table-col--selected]=\"colIndex == selectedCol && !config.selectCell\"\n                [class.ngx-table__table-cell--selected]=\"colIndex == selectedCol && rowIndex == selectedRow && !config.selectCol && !config.selectRow\"\n            >\n              <div>{{ row | render:column.key }}</div>\n            </td>\n          </ng-container>\n        </tr>\n      </ng-container>\n    </ng-container>\n    </tbody>\n    <tbody *ngIf=\"!isLoading && (!data || (data && data.length < 1))\">\n    <tr class=\"ngx-table__body-empty\">\n      <ng-container\n        *ngIf=\"noResultsTemplate\"\n        [ngTemplateOutlet]=\"noResultsTemplate\">\n      </ng-container>\n      <td [attr.colspan]=\"columns && columns.length + 1\" *ngIf=\"!noResultsTemplate\">\n        <div class=\"ngx-table__table-no-results\">\n          No results\n        </div>\n      </td>\n    </tr>\n    </tbody>\n    <tbody *ngIf=\"isLoading\">\n    <tr class=\"ngx-table__body-loading\">\n      <td [attr.colspan]=\"columns && columns.length + 1\">\n        <div [style.height]=\"loadingHeight\"\n             class=\"ngx-table__table-loader-wrapper\">\n          <div class=\"ngx-table__table-loader\"></div>\n        </div>\n      </td>\n    </tr>\n    </tbody>\n    <tfoot *ngIf=\"summaryTemplate\">\n    <tr>\n      <ng-container\n        [ngTemplateOutlet]=\"summaryTemplate\"\n        [ngTemplateOutletContext]=\"{ total: data.length, limit: limit, page: page  }\">\n      </ng-container>\n    </tr>\n    </tfoot>\n  </table>\n  <pagination\n    [attr.id]=\"'pagination' + id\"\n    *ngIf=\"config.paginationEnabled\"\n    [id]=\"id\"\n    #paginationComponent\n    [config]=\"config\"\n    [pagination]=\"pagination\"\n    (updateRange)=\"onPagination($event)\">\n  </pagination>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
BaseComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
BaseComponent.propDecorators = {
    paginationComponent: [{ type: ViewChild, args: ['paginationComponent',] }],
    th: [{ type: ViewChild, args: ['th',] }],
    configuration: [{ type: Input, args: ['configuration',] }],
    data: [{ type: Input }],
    pagination: [{ type: Input }],
    groupRowsBy: [{ type: Input }],
    id: [{ type: Input }],
    toggleRowIndex: [{ type: Input }],
    detailsTemplate: [{ type: Input }],
    summaryTemplate: [{ type: Input }],
    groupRowsHeaderTemplate: [{ type: Input }],
    filtersTemplate: [{ type: Input }],
    selectAllTemplate: [{ type: Input }],
    noResultsTemplate: [{ type: Input }],
    rowContextMenu: [{ type: Input }],
    columns: [{ type: Input }],
    event: [{ type: Output }],
    rowTemplate: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * From version 5.0 CsvExportComponent will be deprecated,
 * and from version 6.0 moved to CsvExportComponent plugin
 */
class CsvExportComponent {
    /**
     * @return {?}
     */
    exportCsv() {
        /** @type {?} */
        const data = this.data;
        /** @type {?} */
        let csvContent = 'data:text/csv;charset=utf-8,';
        /** @type {?} */
        let dataString = '';
        /** @type {?} */
        const x = [];
        /** @type {?} */
        const keys = Object.keys(this.data[0]);
        data.forEach((/**
         * @param {?} row
         * @param {?} index
         * @return {?}
         */
        (row, index) => {
            x[index] = [];
            keys.forEach((/**
             * @param {?} i
             * @return {?}
             */
            (i) => {
                if (row.hasOwnProperty(i)) {
                    if (typeof row[i] === 'object') {
                        row[i] = 'Object'; // so far just change object to "Object" string
                    }
                    x[index].push(row[i]);
                }
            }));
        }));
        csvContent += keys + '\n';
        x.forEach((/**
         * @param {?} row
         * @param {?} index
         * @return {?}
         */
        (row, index) => {
            dataString = row.join(',');
            csvContent += index < data.length ? dataString + '\n' : dataString;
        }));
        /** @type {?} */
        const encodedUri = encodeURI(csvContent);
        /** @type {?} */
        const link = document.createElement('a');
        link.setAttribute('href', encodedUri);
        link.setAttribute('download', 'my_data.csv');
        link.click();
    }
}
CsvExportComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-csv-export',
                template: `
    <a (click)="exportCsv()" class="ngx-menu-item">
      CSV export
    </a>`
            }] }
];
CsvExportComponent.propDecorators = {
    data: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HeaderComponent {
    constructor() {
        this.update = new EventEmitter();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    unifyKey(key) {
        return key.replace('.', '_');
    }
    /**
     * @param {?} input
     * @return {?}
     */
    onSearch(input) {
        this.update.emit([
            { value: input.value, key: this.column.key },
        ]);
    }
}
HeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'table-header',
                template: "<label for=\"search_{{ unifyKey(column.key) }}\">\n  <input type=\"text\"\n         id=\"search_{{ unifyKey(column.key) }}\"\n         aria-label=\"Search\"\n         placeholder=\"{{ column.placeholder ? column.placeholder : column.title }}\"\n         class=\"ngx-table__header-search\"\n         #input\n         (input)=\"onSearch(input)\"\n  >\n</label>\n"
            }] }
];
HeaderComponent.propDecorators = {
    column: [{ type: Input }],
    update: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GlobalSearchPipe {
    /**
     * @param {?} dataArr
     * @param {?} filter
     * @return {?}
     */
    transform(dataArr, filter) {
        if (typeof dataArr === 'undefined') {
            return;
        }
        if (typeof filter === 'undefined' || Object.keys(filter).length === 0 || filter === '') {
            return dataArr;
        }
        return dataArr.filter((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            /** @type {?} */
            const element = JSON.stringify(Object.values(row));
            return element.toLocaleLowerCase().indexOf(filter.toLocaleLowerCase()) !== -1;
        }));
    }
}
GlobalSearchPipe.decorators = [
    { type: Pipe, args: [{
                name: 'global',
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FiltersService {
    /**
     * @param {?} p
     * @param {?} o
     * @return {?}
     */
    static getPath(p, o) {
        // https://github.com/dherges/ng-packagr/issues/696
        /* tslint:disable-next-line */
        /** @type {?} */
        const result = p.reduce((/**
         * @param {?} xs
         * @param {?} x
         * @return {?}
         */
        (xs, x) => (xs && typeof xs[x] !== 'undefined') ? xs[x] : null), o);
        return result;
    }
}
FiltersService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RenderPipe {
    /**
     * @param {?} row
     * @param {?} key
     * @return {?}
     */
    transform(row, key) {
        /** @type {?} */
        const split = key.split('.');
        return FiltersService.getPath(split, row);
    }
}
RenderPipe.decorators = [
    { type: Pipe, args: [{
                name: 'render',
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchPipe {
    constructor() {
        this.filters = {};
    }
    /**
     * @param {?} array
     * @param {?=} filter
     * @param {?=} config
     * @return {?}
     */
    transform(array, filter, config) {
        if (typeof array === 'undefined') {
            return;
        }
        if (typeof filter === 'undefined') {
            return array;
        }
        filter.forEach((/**
         * @param {?} f
         * @return {?}
         */
        (f) => {
            this.filters[f.key] = f.value.toString().toLocaleLowerCase();
            if (Object.keys(f).length === 0 || f.value === '') {
                delete this.filters[f.key];
            }
        }));
        if (config && config.groupRows) {
            return array.map((/**
             * @param {?} arr
             * @return {?}
             */
            (arr) => this.filterGroup(arr)));
        }
        return this.filterGroup(array);
    }
    /**
     * @private
     * @param {?} array
     * @return {?}
     */
    filterGroup(array) {
        return array.filter((/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => {
            return Object.keys(this.filters).every((/**
             * @param {?} c
             * @return {?}
             */
            (c) => {
                /** @type {?} */
                const split = c.split('.');
                /** @type {?} */
                const val = FiltersService.getPath(split, obj);
                /** @type {?} */
                const element = (typeof val === 'object') ? JSON.stringify(val) : val.toString().toLocaleLowerCase();
                /** @type {?} */
                const strings = this.filters[c].split(',');
                return strings.some((/**
                 * @param {?} string
                 * @return {?}
                 */
                (string) => element.indexOf(string.trim()) > -1));
            }));
        }));
    }
}
SearchPipe.decorators = [
    { type: Pipe, args: [{
                name: 'search',
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SortPipe {
    constructor() {
        this.defaultArray = [];
    }
    /**
     * @private
     * @param {?} aV
     * @param {?} bV
     * @return {?}
     */
    static isNaN(aV, bV) {
        return (isNaN(parseFloat(aV)) || !isFinite(aV)) || (isNaN(parseFloat(bV)) || !isFinite(bV));
    }
    /**
     * @private
     * @param {?} a
     * @param {?} b
     * @param {?} key
     * @return {?}
     */
    static compare(a, b, key) {
        /** @type {?} */
        const split = key.split('.');
        /** @type {?} */
        const aPath = FiltersService.getPath(split, a);
        /** @type {?} */
        const bPath = FiltersService.getPath(split, b);
        /** @type {?} */
        const aValue = (aPath + '').toLowerCase();
        /** @type {?} */
        const bValue = (bPath + '').toLowerCase();
        if (SortPipe.isNaN(aPath, bPath)) {
            return aValue.localeCompare(bValue);
        }
        else {
            if (parseFloat(aPath) < parseFloat(bPath)) {
                return -1;
            }
            if (parseFloat(aPath) > parseFloat(bPath)) {
                return 1;
            }
        }
        return 0;
    }
    /**
     * @param {?} array
     * @param {?=} filter
     * @param {?=} config
     * @return {?}
     */
    transform(array, filter, config) {
        if (this.defaultArray.length === 0) {
            this.defaultArray = array;
        }
        if (!filter.key || filter.key === '') {
            return array;
        }
        if (filter.order === '') {
            return this.defaultArray;
        }
        if (filter.order === 'asc') {
            return this.sortAsc(config, array, filter);
        }
        else {
            return this.sortDesc(config, array, filter);
        }
    }
    /**
     * @private
     * @param {?} config
     * @param {?} array
     * @param {?} filter
     * @return {?}
     */
    sortAsc(config, array, filter) {
        if (config && config.groupRows) {
            return array.map((/**
             * @param {?} arr
             * @return {?}
             */
            (arr) => arr.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => SortPipe.compare(a, b, filter.key)))));
        }
        return array.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => SortPipe.compare(a, b, filter.key)));
    }
    /**
     * @private
     * @param {?} config
     * @param {?} array
     * @param {?} filter
     * @return {?}
     */
    sortDesc(config, array, filter) {
        if (config && config.groupRows) {
            return array.map((/**
             * @param {?} arr
             * @return {?}
             */
            (arr) => arr.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => SortPipe.compare(b, a, filter.key)))));
        }
        return array.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => SortPipe.compare(b, a, filter.key)));
    }
}
SortPipe.decorators = [
    { type: Pipe, args: [{
                name: 'sort',
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BaseModule {
}
BaseModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    BaseComponent,
                    CsvExportComponent,
                    HeaderComponent,
                    PaginationComponent,
                    SearchPipe,
                    RenderPipe,
                    GlobalSearchPipe,
                    SortPipe,
                ],
                imports: [
                    CommonModule,
                    NgxPaginationModule,
                    DragDropModule,
                ],
                exports: [BaseComponent],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TableModule {
}
TableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    BaseModule,
                ],
                bootstrap: [BaseComponent],
                exports: [BaseComponent],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DefaultConfig, TableModule, STYLE, THEME, Event, API, BaseComponent as c, BaseModule as b, CsvExportComponent as f, HeaderComponent as g, PaginationComponent as h, GlobalSearchPipe as k, RenderPipe as j, SearchPipe as i, SortPipe as l, DefaultConfigService as a, GroupRowsService as d, StyleService as e };

//# sourceMappingURL=ngx-easy-table.js.map